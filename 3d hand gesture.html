<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Interactive Gesture Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        canvas { display: block; }
        #ui { position: absolute; top: 20px; left: 20px; color: white; pointer-events: none; text-shadow: 1px 1px 2px black; }
        #video { position: absolute; bottom: 20px; right: 20px; width: 200px; height: 150px; border: 2px solid #444; border-radius: 8px; transform: scaleX(-1); }
    </style>
</head>
<body>
    <div id="ui">
        <h1>Hand Gesture Particles</h1>
        <p>Pinch fingers to expand | Raise hand to change shape</p>
        <p id="status">Status: Loading AI Models...</p>
    </div>
    <video id="video" autoplay></video>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        let scene, camera, renderer, particles, geometry;
        const particleCount = 20000;
        let currentShape = 1; // 0: Sphere, 1: Heart, 2: Saturn
        let targetPositions = new Float32Array(particleCount * 3);
        let currentPositions = new Float32Array(particleCount * 3);
        let morphFactor = 0;

        // --- 1. Three.js Setup ---
        function initScene() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            geometry = new THREE.BufferGeometry();
            const posArray = new Float32Array(particleCount * 3);
            const colorArray = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                posArray[i * 3] = (Math.random() - 0.5) * 10;
                posArray[i * 3 + 1] = (Math.random() - 0.5) * 10;
                posArray[i * 3 + 2] = (Math.random() - 0.5) * 10;

                colorArray[i * 3] = Math.random();
                colorArray[i * 3 + 1] = Math.random();
                colorArray[i * 3 + 2] = 1.0;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));

            const material = new THREE.PointsMaterial({
                size: 0.03,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
            generateShape(0); // Default to Sphere
        }

        // --- 2. Shape Generation Formulas ---
        function generateShape(type) {
            const positions = geometry.attributes.position.array;
            for (let i = 0; i < particleCount; i++) {
                let x, y, z;
                if (type === 0) { // Sphere
                    const u = Math.random();
                    const v = Math.random();
                    const theta = 2 * Math.PI * u;
                    const phi = Math.acos(2 * v - 1);
                    x = 2 * Math.sin(phi) * Math.cos(theta);
                    y = 2 * Math.sin(phi) * Math.sin(theta);
                    z = 2 * Math.cos(phi);
                } else if (type === 1) { // Heart
                    const t = Math.random() * Math.PI * 2;
                    x = 0.15 * (16 * Math.pow(Math.sin(t), 3));
                    y = 0.15 * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                    z = (Math.random() - 0.5) * 0.5;
                } else { // Saturn Rings
                    const r = 2 + Math.random() * 2;
                    const theta = Math.random() * Math.PI * 2;
                    x = r * Math.cos(theta);
                    y = r * Math.sin(theta) * 0.2;
                    z = r * Math.sin(theta);
                }
                targetPositions[i * 3] = x;
                targetPositions[i * 3 + 1] = y;
                targetPositions[i * 3 + 2] = z;
            }
        }

        // --- 3. Hand Tracking (MediaPipe) ---
        const videoElement = document.getElementById('video');
        const statusText = document.getElementById('status');

        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const hand = results.multiHandLandmarks[0];
                statusText.innerText = "Status: Hand Detected";

                // Map wrist (0) to particle position
                particles.position.x = (0.5 - hand[0].x) * 10;
                particles.position.y = (0.5 - hand[0].y) * 10;

                // Pinch distance (thumb index 4 vs 8)
                const dx = hand[4].x - hand[8].x;
                const dy = hand[4].y - hand[8].y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                particles.scale.setScalar(1 + dist * 5);

                // Change shape if hand is high (y < 0.2)
                if (hand[0].y < 0.2) {
                    currentShape = (currentShape + 1) % 3;
                    generateShape(currentShape);
                }
            } else {
                statusText.innerText = "Status: Searching for hand...";
            }
        });

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => { await hands.send({ image: videoElement }); },
            width: 640, height: 480
        });
        cameraFeed.start();

        // --- 4. Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            
            // Smoothly morph particles toward target positions
            const positions = geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i++) {
                positions[i] += (targetPositions[i] - positions[i]) * 0.1;
            }
            geometry.attributes.position.needsUpdate = true;

            particles.rotation.y += 0.005;
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        initScene();
        animate();
    </script>
</body>
</html>